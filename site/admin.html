<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>VPN_GPT — Админ-панель</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0f172a;
        --bg-alt: #111c34;
        --panel: rgba(15, 23, 42, 0.88);
        --border: rgba(148, 163, 184, 0.28);
        --text: #e2e8f0;
        --text-muted: #cbd5f5;
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --success: #22c55e;
        --warning: #f59e0b;
        --error: #ef4444;
        --font-main: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --font-mono: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top left, rgba(14, 116, 244, 0.18), transparent 45%),
          linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
        color: var(--text);
        font-family: var(--font-main);
        display: flex;
        flex-direction: column;
      }

      header {
        padding: clamp(1.6rem, 1.2rem + 1.5vw, 2.6rem) clamp(1.5rem, 1.1rem + 1vw, 3rem) 1.25rem;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.12), rgba(14, 165, 233, 0.25));
        border-bottom: 1px solid rgba(148, 163, 184, 0.22);
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.8rem, 1.3rem + 1.6vw, 2.8rem);
        letter-spacing: 0.015em;
      }

      header p {
        margin: 0.75rem 0 0;
        max-width: 72ch;
        color: var(--text-muted);
        font-size: clamp(1rem, 0.95rem + 0.2vw, 1.1rem);
      }

      main {
        flex: 1 1 auto;
        padding: clamp(1.5rem, 1.2rem + 1vw, 3rem);
        display: grid;
        gap: clamp(1.5rem, 1.1rem + 1vw, 2.5rem);
      }

      .control-panel {
        display: grid;
        gap: 1rem;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: clamp(1.5rem, 1.3rem + 0.8vw, 2.1rem);
        backdrop-filter: blur(16px);
      }

      .control-grid {
        display: grid;
        gap: 0.85rem;
      }

      .control-grid label {
        display: grid;
        gap: 0.4rem;
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      .control-grid input[type="text"],
      .control-grid input[type="search"] {
        width: 100%;
        padding: 0.65rem 0.9rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: rgba(15, 23, 42, 0.4);
        color: var(--text);
        font-size: 1rem;
        transition: border 160ms ease, box-shadow 160ms ease;
      }

      .control-grid input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
      }

      .control-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        font: inherit;
      }

      .button-primary,
      .button-secondary {
        border: none;
        border-radius: 999px;
        padding: 0.7rem 1.4rem;
        font-weight: 600;
        letter-spacing: 0.03em;
        cursor: pointer;
        transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      }

      .button-primary {
        background: var(--accent);
        color: #0f172a;
      }

      .button-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(56, 189, 248, 0.28);
      }

      .button-secondary {
        background: rgba(148, 163, 184, 0.2);
        color: var(--text);
      }

      .button-secondary:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(148, 163, 184, 0.28);
      }

      .operations-panel {
        display: grid;
        gap: 1.25rem;
      }

      .operations-meta {
        color: var(--text-muted);
        margin: 0;
        font-size: 0.95rem;
      }

      .operations-layout {
        display: grid;
        gap: 1rem;
      }

      @media (min-width: 880px) {
        .operations-layout {
          grid-template-columns: minmax(220px, 280px) 1fr;
          align-items: start;
        }
      }

      .operations-menu {
        display: grid;
        gap: 0.6rem;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.28);
        border-radius: 16px;
        padding: 1rem;
      }

      .operations-menu h2 {
        margin: 0 0 0.25rem;
        font-size: 0.95rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: rgba(226, 232, 240, 0.75);
      }

      .menu-list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 0.4rem;
      }

      .menu-item {
        margin: 0;
      }

      .menu-button {
        width: 100%;
        border: 1px solid transparent;
        background: rgba(148, 163, 184, 0.08);
        color: inherit;
        border-radius: 12px;
        padding: 0.65rem 0.9rem;
        text-align: left;
        cursor: pointer;
        transition: border 150ms ease, background 150ms ease, transform 150ms ease, box-shadow 150ms ease;
      }

      .menu-button:hover,
      .menu-button:focus-visible {
        outline: none;
        border-color: rgba(56, 189, 248, 0.5);
        background: rgba(56, 189, 248, 0.15);
        transform: translateX(2px);
        box-shadow: 0 6px 18px rgba(14, 165, 233, 0.18);
      }

      .menu-button[aria-pressed="true"] {
        background: rgba(56, 189, 248, 0.2);
        border-color: rgba(56, 189, 248, 0.6);
        box-shadow: 0 8px 22px rgba(14, 165, 233, 0.25);
      }

      .menu-button .menu-label {
        display: block;
        font-weight: 600;
      }

      .menu-button .menu-meta {
        display: block;
        font-size: 0.82rem;
        color: rgba(203, 213, 225, 0.8);
        margin-top: 0.2rem;
      }

      .operations-content {
        display: grid;
        gap: 1rem;
      }

      .operations-content h2 {
        margin: 0;
        font-size: 1.05rem;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: rgba(226, 232, 240, 0.78);
      }

      .operation-buttons {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .operation-button {
        display: grid;
        gap: 0.4rem;
        padding: 1rem 1.1rem;
        background: rgba(15, 23, 42, 0.58);
        border: 1px solid rgba(148, 163, 184, 0.24);
        border-radius: 16px;
        text-align: left;
        cursor: pointer;
        transition: transform 150ms ease, border 150ms ease, background 150ms ease, box-shadow 150ms ease;
        position: relative;
        overflow: hidden;
      }

      .operation-button:hover {
        transform: translateY(-2px);
        border-color: rgba(56, 189, 248, 0.6);
        background: rgba(30, 41, 59, 0.72);
        box-shadow: 0 12px 32px rgba(14, 165, 233, 0.22);
      }

      .operation-button .label {
        font-weight: 600;
        font-size: 1.05rem;
      }

      .operation-button .hint {
        color: rgba(203, 213, 225, 0.8);
        font-family: var(--font-mono);
        font-size: 0.85rem;
      }

      .operation-button .description {
        color: rgba(203, 213, 225, 0.75);
        font-size: 0.9rem;
      }

      .method-badge {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        padding: 0.25rem 0.65rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 700;
        letter-spacing: 0.08em;
      }

      .method-get {
        color: var(--success);
        background: rgba(34, 197, 94, 0.15);
      }

      .method-post {
        color: var(--accent);
        background: rgba(56, 189, 248, 0.18);
      }

      .method-put,
      .method-patch {
        color: var(--warning);
        background: rgba(245, 158, 11, 0.18);
      }

      .method-delete {
        color: var(--error);
        background: rgba(239, 68, 68, 0.2);
      }

      .empty-state {
        border: 2px dashed rgba(148, 163, 184, 0.25);
        border-radius: 18px;
        padding: 3rem 1.5rem;
        text-align: center;
        color: var(--text-muted);
        font-size: 1rem;
      }

      .status-bar {
        padding: 0.85rem 1.1rem;
        border-radius: 12px;
        border: 1px solid transparent;
        display: none;
        font-weight: 500;
      }

      .status-bar.visible {
        display: block;
      }

      .status-bar.tone-info {
        border-color: rgba(56, 189, 248, 0.35);
        background: rgba(56, 189, 248, 0.12);
        color: var(--accent);
      }

      .status-bar.tone-success {
        border-color: rgba(34, 197, 94, 0.4);
        background: rgba(34, 197, 94, 0.12);
        color: var(--success);
      }

      .status-bar.tone-warning {
        border-color: rgba(245, 158, 11, 0.4);
        background: rgba(245, 158, 11, 0.12);
        color: var(--warning);
      }

      .status-bar.tone-error {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(239, 68, 68, 0.12);
        color: var(--error);
      }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.65);
        backdrop-filter: blur(8px);
        display: grid;
        place-items: center;
        padding: 1.5rem;
        z-index: 1000;
      }

      .modal-overlay[hidden] {
        display: none;
      }

      .modal-card {
        width: min(720px, 100%);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 20px;
        padding: clamp(1.6rem, 1.4rem + 1vw, 2.3rem);
        display: grid;
        gap: 1.25rem;
        box-shadow: 0 40px 60px rgba(15, 23, 42, 0.5);
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.4);
        color: var(--text);
        border-radius: 999px;
        padding: 0.35rem 0.8rem;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: transform 120ms ease, border 120ms ease;
      }

      .modal-close:hover {
        transform: translateY(-1px);
        border-color: rgba(56, 189, 248, 0.5);
      }

      .modal-header h3 {
        margin: 0;
        font-size: 1.4rem;
      }

      .modal-header p {
        margin: 0.35rem 0 0;
        color: var(--text-muted);
      }

      .modal-path {
        font-family: var(--font-mono);
        font-size: 0.95rem;
        color: rgba(203, 213, 225, 0.85);
      }

      .endpoint-form {
        display: grid;
        gap: 1rem;
      }

      fieldset {
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 14px;
        padding: 1rem;
        display: grid;
        gap: 0.75rem;
      }

      fieldset legend {
        padding: 0 0.35rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(226, 232, 240, 0.8);
      }

      .param-field {
        display: grid;
        gap: 0.4rem;
      }

      .param-field label {
        display: grid;
        gap: 0.3rem;
        font-size: 0.95rem;
      }

      .param-field input[type="text"],
      .endpoint-form textarea {
        width: 100%;
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.35);
        color: var(--text);
        font-size: 0.95rem;
        transition: border 150ms ease, box-shadow 150ms ease;
      }

      .param-field input:focus,
      .endpoint-form textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.28);
      }

      .endpoint-form textarea {
        font-family: var(--font-mono);
        min-height: 7rem;
        resize: vertical;
      }

      .param-meta {
        color: rgba(203, 213, 225, 0.75);
        font-size: 0.85rem;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .submit-btn {
        border: none;
        background: var(--accent-strong);
        color: #0f172a;
        padding: 0.75rem 1.6rem;
        border-radius: 12px;
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      .submit-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 30px rgba(14, 165, 233, 0.32);
      }

      .response {
        display: grid;
        gap: 0.55rem;
      }

      .response-view {
        background: rgba(15, 23, 42, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 14px;
        padding: 1rem;
        display: grid;
        gap: 0.75rem;
        font-size: 0.95rem;
      }

      .response-view .empty-response {
        color: rgba(203, 213, 225, 0.75);
      }

      .response-dl {
        display: grid;
        gap: 0.5rem;
      }

      .response-row {
        display: grid;
        gap: 0.35rem;
        padding: 0.55rem 0.75rem;
        border-radius: 10px;
        background: rgba(148, 163, 184, 0.08);
      }

      .response-highlight {
        background: rgba(56, 189, 248, 0.16);
        border: 1px solid rgba(56, 189, 248, 0.3);
      }

      .response-row-title {
        font-weight: 600;
        font-size: 0.92rem;
        letter-spacing: 0.02em;
      }

      .response-row-value {
        color: rgba(226, 232, 240, 0.9);
      }

      .response-primitive {
        display: inline-block;
        word-break: break-word;
      }

      .response-list {
        display: grid;
        gap: 0.5rem;
        padding-left: 1rem;
        margin: 0;
        list-style: none;
      }

      .response-list-item {
        padding: 0.5rem 0.75rem;
        border-radius: 10px;
        background: rgba(148, 163, 184, 0.08);
      }

      .response-multi {
        display: grid;
        gap: 0.5rem;
      }

      .operations-hint {
        font-size: 0.85rem;
        color: rgba(203, 213, 225, 0.78);
      }

      .status {
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .status.ok {
        color: var(--success);
      }

      .status.error {
        color: var(--error);
      }

      .status.pending {
        color: var(--warning);
      }

      pre {
        margin: 0;
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: var(--font-mono);
        font-size: 0.9rem;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        z-index: 1200;
      }

      .auth-overlay[hidden] {
        display: none;
      }

      .auth-card {
        width: min(420px, 90vw);
        display: grid;
        gap: 1.25rem;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: clamp(1.8rem, 1.4rem + 1vw, 2.4rem);
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
      }

      .auth-card h2 {
        margin: 0;
        font-size: clamp(1.4rem, 1.2rem + 0.6vw, 1.9rem);
      }

      .auth-card p {
        margin: 0;
        color: var(--text-muted);
      }

      .auth-field {
        display: grid;
        gap: 0.5rem;
      }

      .auth-field span {
        font-size: 0.95rem;
        color: var(--text-muted);
        letter-spacing: 0.03em;
      }

      .auth-card input[type="password"] {
        width: 100%;
        padding: 0.65rem 0.85rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: rgba(15, 23, 42, 0.45);
        color: var(--text);
        font-size: 1rem;
      }

      .auth-card input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
      }

      .auth-error {
        min-height: 1.2rem;
        color: var(--error);
        font-size: 0.9rem;
      }

      @media (min-width: 720px) {
        .control-grid {
          grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .control-grid label {
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Центр управления VPN_GPT</h1>
      <p>
        Выберите действие в понятных терминах, а затем заполните необходимые данные в появляющемся окне.
        Каждый запрос отправляется к API после подтверждения.
      </p>
    </header>
    <main>
      <section class="control-panel">
        <div class="control-grid">
          <label>
            Базовый URL API
            <input type="text" id="base-url" autocomplete="off" value="https://vpn-gpt.store/api" />
          </label>
          <label>
            Токен администратора (X-Admin-Token)
            <input type="text" id="admin-token" autocomplete="off" placeholder="Введите при необходимости" />
          </label>
          <label>
            Поиск по действиям
            <input type="search" id="operation-search" placeholder="Например, пополнить баланс" />
          </label>
        </div>
        <div class="control-actions">
          <button class="button-primary" id="refresh-schema" type="button">Обновить список действий</button>
          <button class="button-secondary" id="clear-search" type="button">Сбросить фильтр</button>
        </div>
        <p class="operations-meta" id="results-summary">Эндпоинты пока не загружены.</p>
      </section>

      <section class="operations-panel">
        <div class="operations-layout" id="operations">
          <nav class="operations-menu" aria-label="Разделы действий" id="operations-menu"></nav>
          <div class="operations-content" id="operations-content"></div>
        </div>
      </section>

      <div id="status-bar" class="status-bar" role="status" aria-live="polite"></div>
    </main>

    <div class="modal-overlay" id="operation-modal" hidden>
      <div class="modal-card">
        <button class="modal-close" type="button" id="operation-close">Закрыть</button>
        <div class="modal-header">
          <h3 id="operation-title">Выберите действие</h3>
          <p class="modal-path" id="operation-subtitle"></p>
          <p id="operation-description"></p>
        </div>
        <form id="operation-form" class="endpoint-form">
          <div id="operation-fields" class="modal-fields"></div>
          <div class="modal-actions">
            <button class="submit-btn" type="submit">Выполнить</button>
          </div>
          <div class="response">
            <div class="status" id="operation-status">Ответ ещё не запрошен</div>
            <div class="response-view" id="operation-response"></div>
          </div>
        </form>
      </div>
    </div>

    <div class="auth-overlay" id="auth-overlay">
      <form class="auth-card" id="auth-form">
        <div>
          <h2>Вход в админ-панель</h2>
          <p>Введите пароль администратора, чтобы получить доступ к действиям.</p>
        </div>
        <div class="auth-field">
          <span>Пароль администратора</span>
          <input type="password" id="admin-password" autocomplete="current-password" required />
        </div>
        <div class="auth-error" id="auth-error"></div>
        <button class="button-primary" id="auth-submit" type="submit">Подтвердить</button>
      </form>
    </div>

    <script>
      const METHOD_PRIORITY = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
      const TAG_ALL_VALUE = "__all";
      const STORAGE_KEYS = {
        baseUrl: "admin-panel.base-url",
        adminToken: "admin-panel.admin-token",
      };
      const DEFAULT_BASE_URL = "https://vpn-gpt.store/api";

      const selectors = {
        baseUrl: document.getElementById("base-url"),
        adminToken: document.getElementById("admin-token"),
        search: document.getElementById("operation-search"),
        refresh: document.getElementById("refresh-schema"),
        clearSearch: document.getElementById("clear-search"),
        operationsLayout: document.getElementById("operations"),
        operationsMenu: document.getElementById("operations-menu"),
        operationsContent: document.getElementById("operations-content"),
        statusBar: document.getElementById("status-bar"),
        resultsSummary: document.getElementById("results-summary"),
        authOverlay: document.getElementById("auth-overlay"),
        authForm: document.getElementById("auth-form"),
        authPassword: document.getElementById("admin-password"),
        authError: document.getElementById("auth-error"),
        authSubmit: document.getElementById("auth-submit"),
        modal: document.getElementById("operation-modal"),
        modalClose: document.getElementById("operation-close"),
        modalTitle: document.getElementById("operation-title"),
        modalSubtitle: document.getElementById("operation-subtitle"),
        modalDescription: document.getElementById("operation-description"),
        modalFields: document.getElementById("operation-fields"),
        operationForm: document.getElementById("operation-form"),
        operationStatus: document.getElementById("operation-status"),
        operationResponse: document.getElementById("operation-response"),
      };

      const state = {
        spec: null,
        operations: [],
        filtered: [],
        filters: {
          query: "",
        },
        activeTag: null,
        session: {
          authenticated: false,
          adminToken: "",
        },
        currentOperation: null,
      };

      function savePreference(key, value) {
        try {
          if (value) {
            window.localStorage.setItem(key, value);
          } else {
            window.localStorage.removeItem(key);
          }
        } catch (error) {
          console.warn("Не удалось сохранить настройки", error);
        }
      }

      function loadPreference(key) {
        try {
          return window.localStorage.getItem(key) || "";
        } catch (error) {
          return "";
        }
      }

      function setStatus(message, tone = "info") {
        selectors.statusBar.textContent = message;
        selectors.statusBar.className = `status-bar visible tone-${tone}`;
      }

      function clearStatus() {
        selectors.statusBar.className = "status-bar";
        selectors.statusBar.textContent = "";
      }

      function resolveBaseUrl() {
        const value = selectors.baseUrl.value.trim();
        if (!value) {
          selectors.baseUrl.value = DEFAULT_BASE_URL;
          return DEFAULT_BASE_URL;
        }
        return value.replace(/\/$/, "");
      }

      function buildApiUrl(pathname) {
        const baseValue = resolveBaseUrl();
        let base;
        try {
          base = new URL(baseValue);
        } catch (error) {
          base = new URL(DEFAULT_BASE_URL);
        }

        if (/^https?:\/\//i.test(pathname)) {
          return new URL(pathname);
        }

        const normalized = pathname.startsWith("/") ? pathname : `/${pathname}`;

        if (normalized.startsWith("/") && base.pathname && base.pathname !== "/") {
          const merged = new URL(base.toString());
          const prefix = merged.pathname.endsWith("/") ? merged.pathname.slice(0, -1) : merged.pathname;
          merged.pathname = `${prefix}${normalized}`;
          return merged;
        }

        try {
          return new URL(normalized, base);
        } catch (error) {
          const fallback = new URL(base.toString());
          const prefix = fallback.pathname.endsWith("/") ? fallback.pathname.slice(0, -1) : fallback.pathname;
          fallback.pathname = `${prefix}${normalized}`;
          return fallback;
        }
      }

      async function authenticateWithPassword(password) {
        const body = new URLSearchParams();
        body.set("password", password);

        const baseValue = resolveBaseUrl();
        let hasApiSegment = false;

        try {
          const parsedBase = new URL(baseValue);
          const path = parsedBase.pathname || "/";
          hasApiSegment = /(^|\/)api(\/|$)/.test(path);
        } catch (error) {
          hasApiSegment = false;
        }

        const candidatePaths = ["/admin/auth"];
        if (!hasApiSegment) {
          candidatePaths.push("/api/admin/auth");
        }

        let lastError = null;

        for (const path of candidatePaths) {
          const url = buildApiUrl(path);

          try {
            return await submitAdminPassword(url, body);
          } catch (error) {
            if (error && (error.status === 404 || error.status === 405)) {
              lastError = error;
              continue;
            }
            throw error;
          }
        }

        throw lastError || new Error("Не удалось авторизоваться");
      }

      async function submitAdminPassword(url, body) {
        const response = await fetch(url.toString(), {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
          },
          body,
        });

        let payload = null;
        try {
          payload = await response.json();
        } catch (error) {}

        if (!response.ok) {
          const detail = (payload && (payload.detail || payload.error)) || `Ошибка ${response.status}`;
          const failure = new Error(detail);
          failure.status = response.status;
          failure.payload = payload;
          throw failure;
        }

        if (!payload || payload.ok !== true) {
          const message = (payload && (payload.detail || payload.error)) || "Не удалось авторизоваться";
          throw new Error(message);
        }

        return payload;
      }

      async function loadOpenApi({ silent = false } = {}) {
        if (!state.session.authenticated) {
          if (!silent) {
            setStatus("Введите админ-пароль, чтобы загрузить список действий", "warning");
          }
          return;
        }

        try {
          if (!silent) {
            setStatus("Загружаем OpenAPI-схему…", "info");
          }
          const url = buildApiUrl("/openapi.json");
          const headers = { Accept: "application/json" };
          const adminToken = (selectors.adminToken.value || "").trim() || state.session.adminToken;
          if (adminToken) {
            headers["X-Admin-Token"] = adminToken;
          }
          const response = await fetch(url.toString(), { cache: "no-store", headers });
          if (!response.ok) {
            throw new Error(`Не удалось загрузить схему: ${response.status}`);
          }
          const spec = await response.json();
          state.spec = spec;
          state.operations = collectOperationsFromSpec(spec);
          state.filtered = state.operations.slice();
          renderOperations();
          const total = state.operations.length;
          const summary = total
            ? `Загружено ${total} действий. Используйте поиск или выберите нужную кнопку.`
            : "Действия не найдены в схеме.";
          setStatus(summary, total ? "success" : "warning");
          setTimeout(clearStatus, 4500);
        } catch (error) {
          console.error(error);
          setStatus(error.message || "Не удалось загрузить OpenAPI", "error");
        }
      }

      function collectOperationsFromSpec(spec) {
        if (!spec || !spec.paths) {
          return [];
        }
        const operations = [];
        Object.entries(spec.paths).forEach(([path, methods]) => {
          Object.entries(methods || {}).forEach(([methodName, operation]) => {
            if (!operation || typeof operation !== "object") {
              return;
            }
            const method = methodName.toUpperCase();
            if (!METHOD_PRIORITY.includes(method)) {
              return;
            }
            const summary = (operation.summary || "").trim();
            const description = (operation.description || "").trim();
            const label = summary || humanizePath(path, method);
            const primaryTag = (operation.tags && operation.tags[0]) || "Общие действия";
            operations.push({
              method,
              path,
              operation,
              summary,
              description,
              label,
              primaryTag,
            });
          });
        });

        operations.sort((a, b) => {
          if (a.primaryTag !== b.primaryTag) {
            return a.primaryTag.localeCompare(b.primaryTag, "ru");
          }
          const methodDiff = METHOD_PRIORITY.indexOf(a.method) - METHOD_PRIORITY.indexOf(b.method);
          if (methodDiff !== 0) {
            return methodDiff;
          }
          return a.path.localeCompare(b.path, "ru");
        });

        operations.forEach((operation, index) => {
          operation.index = index;
        });

        return operations;
      }

      function humanizePath(path, method) {
        const clean = path
          .replace(/^\//, "")
          .replace(/\{([^}]+)\}/g, "«$1»")
          .replace(/[-_]/g, " ")
          .trim();
        const base = clean ? clean : "действие";
        switch (method) {
          case "GET":
            return `Получить: ${base}`;
          case "POST":
            return `Создать или запустить: ${base}`;
          case "PUT":
          case "PATCH":
            return `Обновить: ${base}`;
          case "DELETE":
            return `Удалить: ${base}`;
          default:
            return `${method} ${path}`;
        }
      }
      function renderOperations() {
        if (!selectors.operationsLayout) return;

        const menu = selectors.operationsMenu;
        const content = selectors.operationsContent;

        if (!menu || !content) {
          return;
        }

        menu.innerHTML = "";
        content.innerHTML = "";

        const query = (state.filters.query || "").trim().toLowerCase();
        const filtered = !query
          ? state.operations
          : state.operations.filter((operation) => {
              const haystack = [
                operation.label,
                operation.summary,
                operation.description,
                operation.path,
                operation.method,
                ...(operation.operation.tags || []),
              ]
                .join(" ")
                .toLowerCase();
              return haystack.includes(query);
            });

        state.filtered = filtered;
        updateResultsSummary(state.operations.length, filtered.length);

        if (!filtered.length) {
          state.activeTag = null;
          const placeholder = document.createElement("div");
          placeholder.className = "empty-state";
          placeholder.textContent = state.operations.length
            ? "Ничего не найдено. Измените текст поиска."
            : "Список действий ещё не загружен. Авторизуйтесь и обновите схему.";
          content.appendChild(placeholder);
          return;
        }

        const groups = new Map();
        filtered.forEach((operation) => {
          const key = operation.primaryTag || TAG_ALL_VALUE;
          if (!groups.has(key)) {
            groups.set(key, []);
          }
          groups.get(key).push(operation);
        });

        const tags = Array.from(groups.keys());

        if (!state.activeTag || !groups.has(state.activeTag)) {
          state.activeTag = tags[0];
        }

        const menuHeading = document.createElement("h2");
        menuHeading.textContent = "Разделы";
        menu.appendChild(menuHeading);

        const list = document.createElement("ul");
        list.className = "menu-list";
        menu.appendChild(list);

        tags.forEach((tag) => {
          const item = document.createElement("li");
          item.className = "menu-item";

          const button = document.createElement("button");
          button.type = "button";
          button.className = "menu-button";
          button.setAttribute("aria-pressed", String(state.activeTag === tag));

          const label = document.createElement("span");
          label.className = "menu-label";
          label.textContent = tag;
          button.appendChild(label);

          const meta = document.createElement("span");
          meta.className = "menu-meta";
          meta.textContent = `${groups.get(tag).length} действий`;
          button.appendChild(meta);

          button.addEventListener("click", () => {
            if (state.activeTag === tag) {
              return;
            }
            state.activeTag = tag;
            renderOperations();
          });

          item.appendChild(button);
          list.appendChild(item);
        });

        const currentOperations = groups.get(state.activeTag) || [];

        const sectionHeading = document.createElement("h2");
        sectionHeading.textContent = state.activeTag;
        content.appendChild(sectionHeading);

        if (!currentOperations.length) {
          const emptySection = document.createElement("div");
          emptySection.className = "empty-state";
          emptySection.textContent = "В этом разделе действий не найдено.";
          content.appendChild(emptySection);
          return;
        }

        const hint = document.createElement("p");
        hint.className = "operations-hint";
        hint.textContent = "Выберите функцию из списка, чтобы открыть окно с подробностями.";
        content.appendChild(hint);

        const grid = document.createElement("div");
        grid.className = "operation-buttons";
        content.appendChild(grid);

        currentOperations.forEach((operation) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "operation-button";
          button.dataset.index = operation.index;

          const label = document.createElement("span");
          label.className = "label";
          label.textContent = operation.label;
          button.appendChild(label);

          const hint = document.createElement("span");
          hint.className = "hint";
          hint.textContent = `${operation.method} ${operation.path}`;
          button.appendChild(hint);

          if (operation.description) {
            const desc = document.createElement("span");
            desc.className = "description";
            desc.textContent = operation.description;
            button.appendChild(desc);
          }

          const badge = document.createElement("span");
          badge.className = `method-badge method-${operation.method.toLowerCase()}`;
          badge.textContent = operation.method;
          button.appendChild(badge);

          button.addEventListener("click", () => openOperationModal(operation));

          grid.appendChild(button);
        });
      }

      function openOperationModal(operation) {
        state.currentOperation = operation;
        selectors.modalTitle.textContent = operation.label;
        selectors.modalSubtitle.textContent = `${operation.method} ${operation.path}`;
        selectors.modalDescription.textContent = operation.description || "";
        selectors.operationStatus.textContent = "Ответ ещё не запрошен";
        selectors.operationStatus.className = "status";
        selectors.operationResponse.innerHTML = "";
        const placeholder = document.createElement("p");
        placeholder.className = "empty-response";
        placeholder.textContent = "После выполнения запроса здесь появится результат.";
        selectors.operationResponse.appendChild(placeholder);

        selectors.operationForm.dataset.method = operation.method;
        selectors.operationForm.dataset.path = operation.path;

        selectors.modalFields.innerHTML = "";
        const parameterGroups = buildParameterGroups(operation.operation.parameters || []);
        parameterGroups.forEach((group) => selectors.modalFields.appendChild(group));

        if (operation.operation.requestBody) {
          selectors.modalFields.appendChild(buildRequestBody(operation.operation.requestBody));
        }

        selectors.modalFields.appendChild(buildHeadersFieldset());

        selectors.modal.removeAttribute("hidden");
        const firstInput = selectors.modalFields.querySelector("input, textarea");
        if (firstInput) {
          firstInput.focus();
        } else {
          selectors.operationForm.querySelector(".submit-btn").focus();
        }
      }

      function closeOperationModal() {
        state.currentOperation = null;
        selectors.operationForm.dataset.method = "";
        selectors.operationForm.dataset.path = "";
        selectors.modalFields.innerHTML = "";
        selectors.modal.setAttribute("hidden", "");
      }

      function buildParameterGroups(parameters) {
        const byLocation = new Map();
        parameters.forEach((param) => {
          if (!param || !param.name) return;
          const location = param.in || "query";
          if (!byLocation.has(location)) {
            const fieldset = document.createElement("fieldset");
            fieldset.dataset.group = location;
            const legend = document.createElement("legend");
            legend.textContent =
              location === "path"
                ? "Параметры пути"
                : location === "query"
                ? "Query-параметры"
                : location === "header"
                ? "Заголовки"
                : location === "cookie"
                ? "Cookie"
                : location;
            fieldset.appendChild(legend);
            byLocation.set(location, fieldset);
          }
          const fieldset = byLocation.get(location);
          fieldset.appendChild(buildParameterField(param));
        });
        return Array.from(byLocation.values());
      }

      function buildParameterField(parameter) {
        const wrapper = document.createElement("div");
        wrapper.className = "param-field";

        const label = document.createElement("label");
        label.textContent = parameter.name + (parameter.required ? " *" : "");

        const input = document.createElement("input");
        input.type = "text";
        input.name = parameter.name;
        input.dataset.paramType = parameter.in;
        input.placeholder = parameter.schema?.type || "";
        if (parameter.schema && "default" in parameter.schema) {
          input.value = parameter.schema.default;
        }
        if (parameter.required) {
          input.required = true;
        }

        label.appendChild(input);
        wrapper.appendChild(label);

        if (parameter.description) {
          const meta = document.createElement("div");
          meta.className = "param-meta";
          meta.textContent = parameter.description;
          wrapper.appendChild(meta);
        }
        return wrapper;
      }

      function buildRequestBody(requestBody) {
        const fieldset = document.createElement("fieldset");
        fieldset.dataset.group = "body";
        const legend = document.createElement("legend");
        legend.textContent = "Тело запроса";
        fieldset.appendChild(legend);

        const description = requestBody.description;
        if (description) {
          const meta = document.createElement("div");
          meta.className = "param-meta";
          meta.textContent = description;
          fieldset.appendChild(meta);
        }

        const textarea = document.createElement("textarea");
        textarea.dataset.role = "body";
        textarea.placeholder = "JSON";
        const example = extractExampleFromRequest(requestBody);
        if (example) {
          textarea.value = example;
        }
        fieldset.appendChild(textarea);
        return fieldset;
      }

      function buildHeadersFieldset() {
        const fieldset = document.createElement("fieldset");
        const legend = document.createElement("legend");
        legend.textContent = "Дополнительные заголовки (JSON)";
        fieldset.appendChild(legend);

        const textarea = document.createElement("textarea");
        textarea.dataset.role = "headers";
        textarea.placeholder = '{"Custom-Header": "value"}';
        textarea.rows = 4;
        fieldset.appendChild(textarea);
        return fieldset;
      }

      function extractExampleFromRequest(requestBody) {
        const content = requestBody.content || {};
        const jsonContent = content["application/json"] || content["application/*"];
        if (!jsonContent) {
          return "";
        }
        const example =
          jsonContent.example ||
          (Array.isArray(jsonContent.examples)
            ? jsonContent.examples[0]
            : jsonContent.examples && typeof jsonContent.examples === "object"
            ? Object.values(jsonContent.examples)[0]?.value
            : null);
        if (example) {
          return formatJson(example);
        }
        const schema = jsonContent.schema;
        if (!schema) return "";
        const sample = buildSampleFromSchema(schema, state.spec?.components?.schemas || {});
        return sample ? formatJson(sample) : "";
      }

      function buildSampleFromSchema(schema, definitions, stack = new Set()) {
        if (!schema) return null;
        if (schema.example !== undefined) {
          return schema.example;
        }
        if (schema.$ref) {
          const ref = schema.$ref.replace("#/components/schemas/", "");
          if (stack.has(ref)) {
            return null;
          }
          stack.add(ref);
          const resolved = definitions?.[ref];
          const value = buildSampleFromSchema(resolved, definitions, stack);
          stack.delete(ref);
          return value;
        }
        const type = schema.type;
        if (type === "object" || (!type && schema.properties)) {
          const result = {};
          const props = schema.properties || {};
          Object.entries(props).forEach(([key, value]) => {
            result[key] = buildSampleFromSchema(value, definitions, stack) ?? null;
          });
          return result;
        }
        if (type === "array") {
          const item = buildSampleFromSchema(schema.items, definitions, stack);
          return item === null ? [] : [item];
        }
        if (type === "integer" || type === "number") {
          return schema.default ?? 0;
        }
        if (type === "boolean") {
          return schema.default ?? false;
        }
        return schema.default ?? "";
      }

      function formatJson(value) {
        if (typeof value === "string") {
          try {
            return JSON.stringify(JSON.parse(value), null, 2);
          } catch (error) {
            return value;
          }
        }
        try {
          return JSON.stringify(value, null, 2);
        } catch (error) {
          return "";
        }
      }

      function renderFriendlyResponse(container, rawText, metadata = {}) {
        container.innerHTML = "";

        const text = (rawText || "").trim();
        if (!text) {
          container.appendChild(createEmptyResponse("Ответ пустой."));
          return;
        }

        const looksLikeJson = (metadata.contentType || "").includes("json");
        let parsed;
        let parsedSuccessfully = false;

        if (looksLikeJson) {
          try {
            parsed = JSON.parse(text);
            parsedSuccessfully = true;
          } catch (error) {
            parsedSuccessfully = false;
          }
        } else {
          try {
            parsed = JSON.parse(text);
            parsedSuccessfully = true;
          } catch (error) {
            parsedSuccessfully = false;
          }
        }

        if (!parsedSuccessfully) {
          container.appendChild(createPlainResponseBlock("Ответ сервера", text));
          return;
        }

        if (Array.isArray(parsed)) {
          container.appendChild(buildArraySummary(parsed));
          container.appendChild(buildReadableBlock(parsed));
          return;
        }

        if (parsed && typeof parsed === "object") {
          const summary = buildResponseSummary(parsed);
          if (summary) {
            container.appendChild(summary);
          }
          container.appendChild(buildReadableBlock(parsed));
          return;
        }

        container.appendChild(createPlainResponseBlock("Ответ сервера", formatPrimitive(parsed)));
      }

      function createEmptyResponse(message) {
        const paragraph = document.createElement("p");
        paragraph.className = "empty-response";
        paragraph.textContent = message;
        return paragraph;
      }

      function createPlainResponseBlock(title, value) {
        const block = document.createElement("div");
        block.className = "response-row";

        const heading = document.createElement("div");
        heading.className = "response-row-title";
        heading.textContent = title;
        block.appendChild(heading);

        const body = document.createElement("div");
        body.className = "response-row-value";

        const span = document.createElement("span");
        span.className = "response-primitive";
        span.textContent = value;
        body.appendChild(span);

        block.appendChild(body);
        return block;
      }

      function buildResponseSummary(data) {
        if (!data || typeof data !== "object") {
          return null;
        }

        const pieces = [];
        const message = typeof data.message === "string" ? data.message.trim() : "";
        const detail = typeof data.detail === "string" ? data.detail.trim() : "";
        const status = data.status ?? data.result ?? data.state;
        const code = data.code ?? data.error_code;

        if (message) {
          pieces.push(message);
        }

        if (detail && detail !== message) {
          pieces.push(detail);
        }

        if (status !== undefined && status !== null && status !== "") {
          pieces.push(`Статус: ${status}`);
        }

        if (code !== undefined && code !== null && code !== "") {
          pieces.push(`Код: ${code}`);
        }

        if (!pieces.length) {
          return null;
        }

        const row = document.createElement("div");
        row.className = "response-row response-highlight";

        const title = document.createElement("div");
        title.className = "response-row-title";
        title.textContent = "Кратко";
        row.appendChild(title);

        const value = document.createElement("div");
        value.className = "response-row-value";
        const span = document.createElement("span");
        span.className = "response-primitive";
        span.textContent = pieces.join(" · ");
        value.appendChild(span);
        row.appendChild(value);

        return row;
      }

      function buildArraySummary(array) {
        const row = document.createElement("div");
        row.className = "response-row response-highlight";

        const title = document.createElement("div");
        title.className = "response-row-title";
        title.textContent = "Количество записей";
        row.appendChild(title);

        const value = document.createElement("div");
        value.className = "response-row-value";
        const span = document.createElement("span");
        span.className = "response-primitive";
        span.textContent = array.length ? `${array.length} шт.` : "0";
        value.appendChild(span);
        row.appendChild(value);

        return row;
      }

      function buildReadableBlock(value, depth = 0) {
        if (value === null || value === undefined) {
          const span = document.createElement("span");
          span.className = "response-primitive";
          span.textContent = "Нет данных";
          return span;
        }

        if (Array.isArray(value)) {
          const wrapper = document.createElement("div");
          wrapper.className = "response-multi";

          if (!value.length) {
            wrapper.appendChild(createEmptyResponse("Список пуст."));
            return wrapper;
          }

          const list = document.createElement("ul");
          list.className = "response-list";

          value.forEach((item, index) => {
            const listItem = document.createElement("li");
            listItem.className = "response-list-item";

            const header = document.createElement("div");
            header.className = "response-row-title";
            header.textContent = `Элемент ${index + 1}`;
            listItem.appendChild(header);

            const content = document.createElement("div");
            content.className = "response-row-value";
            content.appendChild(buildReadableBlock(item, depth + 1));
            listItem.appendChild(content);

            list.appendChild(listItem);
          });

          wrapper.appendChild(list);
          return wrapper;
        }

        if (typeof value === "object") {
          const entries = Object.entries(value);
          if (!entries.length) {
            const emptyWrapper = document.createElement("div");
            emptyWrapper.className = "response-multi";
            emptyWrapper.appendChild(createEmptyResponse("Данные отсутствуют"));
            return emptyWrapper;
          }

          const container = document.createElement("div");
          container.className = "response-dl";

          entries.forEach(([key, val]) => {
            const row = document.createElement("div");
            row.className = "response-row";

            const title = document.createElement("div");
            title.className = "response-row-title";
            title.textContent = humanizeLabel(key);
            row.appendChild(title);

            const cell = document.createElement("div");
            cell.className = "response-row-value";
            cell.appendChild(buildReadableBlock(val, depth + 1));
            row.appendChild(cell);

            container.appendChild(row);
          });

          return container;
        }

        const span = document.createElement("span");
        span.className = "response-primitive";
        span.textContent = formatPrimitive(value);
        return span;
      }

      function humanizeLabel(key) {
        if (!key) {
          return "Поле";
        }
        const spaced = key
          .replace(/[_-]+/g, " ")
          .replace(/([a-z])([A-Z])/g, "$1 $2")
          .replace(/\s+/g, " ")
          .trim();
        if (!spaced) {
          return "Поле";
        }
        return spaced.charAt(0).toUpperCase() + spaced.slice(1);
      }

      function formatPrimitive(value) {
        if (typeof value === "boolean") {
          return value ? "Да" : "Нет";
        }
        if (typeof value === "number") {
          return Number.isFinite(value)
            ? new Intl.NumberFormat("ru-RU", { maximumFractionDigits: 4 }).format(value)
            : String(value);
        }
        if (value === null || value === undefined) {
          return "Нет данных";
        }
        if (typeof value === "string") {
          const trimmed = value.trim();
          return trimmed || "—";
        }
        return String(value);
      }
      async function submitRequest(form, statusEl, responseContainer) {
        const method = form.dataset.method;
        const path = form.dataset.path;
        let urlPath = path;
        const pathInputs = form.querySelectorAll('[data-param-type="path"]');
        for (const input of pathInputs) {
          const value = input.value.trim();
          if (!value && input.required) {
            statusEl.className = "status error";
            statusEl.textContent = `Параметр ${input.name} обязателен.`;
            return;
          }
          urlPath = urlPath.replace(`{${input.name}}`, encodeURIComponent(value));
        }
        const url = buildApiUrl(urlPath);
        const queryInputs = form.querySelectorAll('[data-param-type="query"]');
        const query = new URLSearchParams(url.search);
        for (const input of queryInputs) {
          const value = input.value.trim();
          if (!value) continue;
          query.set(input.name, value);
        }
        const search = query.toString();
        url.search = search;

        const headers = {
          Accept: "application/json, text/plain;q=0.9, */*;q=0.8",
        };
        const token = selectors.adminToken.value.trim();
        if (token) {
          headers["X-Admin-Token"] = token;
        }

        const extraHeadersField = form.querySelector('textarea[data-role="headers"]');
        const extraHeadersText = extraHeadersField ? extraHeadersField.value.trim() : "";
        if (extraHeadersText) {
          try {
            const parsed = JSON.parse(extraHeadersText);
            Object.entries(parsed).forEach(([key, value]) => {
              if (value !== undefined && value !== null) {
                headers[key] = String(value);
              }
            });
          } catch (error) {
            statusEl.className = "status error";
            statusEl.textContent = `Ошибка парсинга заголовков: ${error.message}`;
            return;
          }
        }

        const requestInit = {
          method,
          headers,
        };

        const bodyField = form.querySelector('textarea[data-role="body"]');
        if (bodyField && method !== "GET" && method !== "DELETE") {
          const bodyValue = bodyField.value.trim();
          if (bodyValue) {
            try {
              JSON.parse(bodyValue);
              requestInit.body = bodyValue;
              headers["Content-Type"] = "application/json";
            } catch (error) {
              statusEl.className = "status error";
              statusEl.textContent = `Некорректный JSON: ${error.message}`;
              return;
            }
          }
        }

        statusEl.className = "status pending";
        statusEl.textContent = "Выполняем запрос…";
        responseContainer.innerHTML = "";
        const waiting = document.createElement("p");
        waiting.className = "empty-response";
        waiting.textContent = "Ожидаем ответ от сервера…";
        responseContainer.appendChild(waiting);

        try {
          const response = await fetch(url.toString(), requestInit);
          const text = await response.text();
          const statusLine = `${response.status} ${response.statusText || ""}`.trim();
          statusEl.className = response.ok ? "status ok" : "status error";
          statusEl.textContent = `Ответ: ${statusLine}`;
          renderFriendlyResponse(responseContainer, text, {
            contentType: response.headers.get("Content-Type") || "",
          });
        } catch (error) {
          statusEl.className = "status error";
          statusEl.textContent = `Ошибка запроса: ${error.message}`;
          responseContainer.innerHTML = "";
          const message = document.createElement("p");
          message.className = "empty-response";
          message.textContent = "Не удалось получить ответ от сервера.";
          responseContainer.appendChild(message);
        }
      }

      function updateResultsSummary(total, shown) {
        if (!selectors.resultsSummary) return;
        if (!total) {
          selectors.resultsSummary.textContent = "Эндпоинты пока не загружены.";
          return;
        }
        const prefix = shown === total ? "Показаны все" : `Показано ${shown} из ${total}`;
        selectors.resultsSummary.textContent = `${prefix} действий`;
      }

      function markAuthenticated(adminToken, { silent = false } = {}) {
        state.session.authenticated = true;
        state.session.adminToken = adminToken || "";
        selectors.authOverlay.hidden = true;
        selectors.authError.textContent = "";
        selectors.authPassword.value = "";

        if (adminToken && !selectors.adminToken.value) {
          selectors.adminToken.value = adminToken;
        }

        savePreference(STORAGE_KEYS.adminToken, selectors.adminToken.value.trim());

        if (!silent) {
          const tone = adminToken ? "success" : "warning";
          const message = adminToken
            ? "Авторизация успешна. Загружаем схему…"
            : "Авторизация успешна, но ADMIN_TOKEN не задан. Укажите его вручную.";
          setStatus(message, tone);
        }
      }

      selectors.operationForm.addEventListener("submit", (event) => {
        event.preventDefault();
        submitRequest(selectors.operationForm, selectors.operationStatus, selectors.operationResponse);
      });

      selectors.modalClose.addEventListener("click", () => {
        closeOperationModal();
      });

      selectors.modal.addEventListener("click", (event) => {
        if (event.target === selectors.modal) {
          closeOperationModal();
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !selectors.modal.hasAttribute("hidden")) {
          closeOperationModal();
        }
      });

      selectors.refresh.addEventListener("click", () => {
        loadOpenApi();
      });

      selectors.clearSearch.addEventListener("click", () => {
        selectors.search.value = "";
        state.filters.query = "";
        renderOperations();
      });

      selectors.search.addEventListener("input", () => {
        state.filters.query = selectors.search.value;
        renderOperations();
      });

      selectors.baseUrl.addEventListener("change", () => {
        savePreference(STORAGE_KEYS.baseUrl, selectors.baseUrl.value.trim());
      });

      selectors.baseUrl.addEventListener("blur", () => {
        savePreference(STORAGE_KEYS.baseUrl, selectors.baseUrl.value.trim());
      });

      selectors.adminToken.addEventListener("input", () => {
        savePreference(STORAGE_KEYS.adminToken, selectors.adminToken.value.trim());
      });

      if (selectors.authForm) {
        selectors.authForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          selectors.authError.textContent = "";
          const password = selectors.authPassword.value.trim();
          if (!password) {
            selectors.authError.textContent = "Введите пароль";
            selectors.authPassword.focus();
            return;
          }

          const button = selectors.authSubmit;
          const originalText = button.textContent;
          button.disabled = true;
          button.textContent = "Проверяем…";

          try {
            const payload = await authenticateWithPassword(password);
            markAuthenticated(payload.admin_token || "", { silent: true });
            await loadOpenApi({ silent: true });
            const hasToken = Boolean(payload.admin_token);
            const message = hasToken
              ? "Авторизация успешна. Схема успешно обновлена"
              : "Схема обновлена. ADMIN_TOKEN не настроен, введите его вручную";
            setStatus(message, hasToken ? "success" : "warning");
            setTimeout(clearStatus, 3500);
          } catch (error) {
            selectors.authError.textContent = error.message || "Не удалось авторизоваться";
            selectors.authPassword.select();
            selectors.authPassword.focus();
          } finally {
            button.disabled = false;
            button.textContent = originalText;
          }
        });
      }

      window.addEventListener("DOMContentLoaded", () => {
        const storedBaseUrl = loadPreference(STORAGE_KEYS.baseUrl);
        if (storedBaseUrl) {
          selectors.baseUrl.value = storedBaseUrl;
        } else {
          selectors.baseUrl.value = DEFAULT_BASE_URL;
        }
        const storedToken = loadPreference(STORAGE_KEYS.adminToken);
        if (storedToken) {
          selectors.adminToken.value = storedToken;
        }
        resolveBaseUrl();
        selectors.authOverlay.hidden = false;
        selectors.authPassword.focus();
        updateResultsSummary(0, 0);
      });
    </script>
  </body>
</html>
