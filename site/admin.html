<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>VPN_GPT — Админ-панель</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0f172a;
        --bg-alt: #111c34;
        --panel: rgba(15, 23, 42, 0.88);
        --border: rgba(148, 163, 184, 0.28);
        --text: #e2e8f0;
        --text-muted: #cbd5f5;
        --accent: #38bdf8;
        --accent-strong: #0ea5e9;
        --success: #22c55e;
        --warning: #f59e0b;
        --error: #ef4444;
        --font-main: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --font-mono: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        background: radial-gradient(circle at top left, rgba(14, 116, 244, 0.18), transparent 45%),
          linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
        color: var(--text);
        font-family: var(--font-main);
        display: flex;
        flex-direction: column;
      }

      header {
        padding: clamp(1.6rem, 1.2rem + 1.5vw, 2.6rem) clamp(1.5rem, 1.1rem + 1vw, 3rem) 1.25rem;
        background: linear-gradient(135deg, rgba(56, 189, 248, 0.12), rgba(14, 165, 233, 0.25));
        border-bottom: 1px solid rgba(148, 163, 184, 0.22);
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.8rem, 1.3rem + 1.6vw, 2.8rem);
        letter-spacing: 0.015em;
      }

      header p {
        margin: 0.75rem 0 0;
        max-width: 72ch;
        color: var(--text-muted);
        font-size: clamp(1rem, 0.95rem + 0.2vw, 1.1rem);
      }

      main {
        flex: 1 1 auto;
        padding: clamp(1.5rem, 1.2rem + 1vw, 3rem);
        display: grid;
        gap: clamp(1.5rem, 1.1rem + 1vw, 2.5rem);
      }

      .control-panel {
        display: grid;
        gap: 1rem;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 18px;
        padding: clamp(1.5rem, 1.3rem + 0.8vw, 2.1rem);
        backdrop-filter: blur(16px);
      }

      .control-grid {
        display: grid;
        gap: 0.85rem;
      }

      .control-grid label {
        display: grid;
        gap: 0.4rem;
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      .control-grid input[type="text"],
      .control-grid input[type="search"] {
        width: 100%;
        padding: 0.65rem 0.9rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: rgba(15, 23, 42, 0.4);
        color: var(--text);
        font-size: 1rem;
        transition: border 160ms ease, box-shadow 160ms ease;
      }

      .control-grid input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
      }

      .control-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      button {
        font: inherit;
      }

      .button-primary,
      .button-secondary {
        border: none;
        border-radius: 999px;
        padding: 0.7rem 1.4rem;
        font-weight: 600;
        letter-spacing: 0.03em;
        cursor: pointer;
        transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease;
      }

      .button-primary {
        background: var(--accent);
        color: #0f172a;
      }

      .button-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(56, 189, 248, 0.28);
      }

      .button-secondary {
        background: rgba(148, 163, 184, 0.2);
        color: var(--text);
      }

      .button-secondary:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(148, 163, 184, 0.28);
      }

      .operations-panel {
        display: grid;
        gap: clamp(1.5rem, 1.2rem + 0.8vw, 2rem);
      }

      .operations-meta {
        color: var(--text-muted);
        margin: 0;
        font-size: 0.95rem;
      }

      .operation-group {
        display: grid;
        gap: 0.85rem;
      }

      .operation-group h2 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        color: rgba(226, 232, 240, 0.8);
      }

      .operation-buttons {
        display: grid;
        gap: 0.75rem;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }

      .operation-button {
        display: grid;
        gap: 0.4rem;
        padding: 1rem 1.1rem;
        background: rgba(15, 23, 42, 0.58);
        border: 1px solid rgba(148, 163, 184, 0.24);
        border-radius: 16px;
        text-align: left;
        cursor: pointer;
        transition: transform 150ms ease, border 150ms ease, background 150ms ease, box-shadow 150ms ease;
        position: relative;
        overflow: hidden;
      }

      .operation-button:hover {
        transform: translateY(-2px);
        border-color: rgba(56, 189, 248, 0.6);
        background: rgba(30, 41, 59, 0.72);
        box-shadow: 0 12px 32px rgba(14, 165, 233, 0.22);
      }

      .operation-button .label {
        font-weight: 600;
        font-size: 1.05rem;
      }

      .operation-button .hint {
        color: rgba(203, 213, 225, 0.8);
        font-family: var(--font-mono);
        font-size: 0.85rem;
      }

      .operation-button .description {
        color: rgba(203, 213, 225, 0.75);
        font-size: 0.9rem;
      }

      .method-badge {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        padding: 0.25rem 0.65rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 700;
        letter-spacing: 0.08em;
      }

      .method-get {
        color: var(--success);
        background: rgba(34, 197, 94, 0.15);
      }

      .method-post {
        color: var(--accent);
        background: rgba(56, 189, 248, 0.18);
      }

      .method-put,
      .method-patch {
        color: var(--warning);
        background: rgba(245, 158, 11, 0.18);
      }

      .method-delete {
        color: var(--error);
        background: rgba(239, 68, 68, 0.2);
      }

      .empty-state {
        border: 2px dashed rgba(148, 163, 184, 0.25);
        border-radius: 18px;
        padding: 3rem 1.5rem;
        text-align: center;
        color: var(--text-muted);
        font-size: 1rem;
      }

      .status-bar {
        padding: 0.85rem 1.1rem;
        border-radius: 12px;
        border: 1px solid transparent;
        display: none;
        font-weight: 500;
      }

      .status-bar.visible {
        display: block;
      }

      .status-bar.tone-info {
        border-color: rgba(56, 189, 248, 0.35);
        background: rgba(56, 189, 248, 0.12);
        color: var(--accent);
      }

      .status-bar.tone-success {
        border-color: rgba(34, 197, 94, 0.4);
        background: rgba(34, 197, 94, 0.12);
        color: var(--success);
      }

      .status-bar.tone-warning {
        border-color: rgba(245, 158, 11, 0.4);
        background: rgba(245, 158, 11, 0.12);
        color: var(--warning);
      }

      .status-bar.tone-error {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(239, 68, 68, 0.12);
        color: var(--error);
      }
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.65);
        backdrop-filter: blur(8px);
        display: grid;
        place-items: center;
        padding: 1.5rem;
        z-index: 1000;
      }

      .modal-overlay[hidden] {
        display: none;
      }

      .modal-card {
        width: min(720px, 100%);
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 20px;
        padding: clamp(1.6rem, 1.4rem + 1vw, 2.3rem);
        display: grid;
        gap: 1.25rem;
        box-shadow: 0 40px 60px rgba(15, 23, 42, 0.5);
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(15, 23, 42, 0.65);
        border: 1px solid rgba(148, 163, 184, 0.4);
        color: var(--text);
        border-radius: 999px;
        padding: 0.35rem 0.8rem;
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: transform 120ms ease, border 120ms ease;
      }

      .modal-close:hover {
        transform: translateY(-1px);
        border-color: rgba(56, 189, 248, 0.5);
      }

      .modal-header h3 {
        margin: 0;
        font-size: 1.4rem;
      }

      .modal-header p {
        margin: 0.35rem 0 0;
        color: var(--text-muted);
      }

      .modal-path {
        font-family: var(--font-mono);
        font-size: 0.95rem;
        color: rgba(203, 213, 225, 0.85);
      }

      .endpoint-form {
        display: grid;
        gap: 1rem;
      }

      fieldset {
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 14px;
        padding: 1rem;
        display: grid;
        gap: 0.75rem;
      }

      fieldset legend {
        padding: 0 0.35rem;
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(226, 232, 240, 0.8);
      }

      .param-field {
        display: grid;
        gap: 0.4rem;
      }

      .param-field label {
        display: grid;
        gap: 0.3rem;
        font-size: 0.95rem;
      }

      .param-field input[type="text"],
      .endpoint-form textarea {
        width: 100%;
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.35);
        color: var(--text);
        font-size: 0.95rem;
        transition: border 150ms ease, box-shadow 150ms ease;
      }

      .param-field input:focus,
      .endpoint-form textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.28);
      }

      .endpoint-form textarea {
        font-family: var(--font-mono);
        min-height: 7rem;
        resize: vertical;
      }

      .param-meta {
        color: rgba(203, 213, 225, 0.75);
        font-size: 0.85rem;
      }

      .modal-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.75rem;
        flex-wrap: wrap;
      }

      .submit-btn {
        border: none;
        background: var(--accent-strong);
        color: #0f172a;
        padding: 0.75rem 1.6rem;
        border-radius: 12px;
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        transition: transform 120ms ease, box-shadow 120ms ease;
      }

      .submit-btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 30px rgba(14, 165, 233, 0.32);
      }

      .response {
        display: grid;
        gap: 0.55rem;
      }

      .status {
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .status.ok {
        color: var(--success);
      }

      .status.error {
        color: var(--error);
      }

      .status.pending {
        color: var(--warning);
      }

      pre {
        margin: 0;
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.28);
        background: rgba(15, 23, 42, 0.6);
        color: var(--text);
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: var(--font-mono);
        font-size: 0.9rem;
      }

      .auth-overlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.88));
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        z-index: 1200;
      }

      .auth-overlay[hidden] {
        display: none;
      }

      .auth-card {
        width: min(420px, 90vw);
        display: grid;
        gap: 1.25rem;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid var(--border);
        border-radius: 20px;
        padding: clamp(1.8rem, 1.4rem + 1vw, 2.4rem);
        box-shadow: 0 28px 60px rgba(15, 23, 42, 0.45);
      }

      .auth-card h2 {
        margin: 0;
        font-size: clamp(1.4rem, 1.2rem + 0.6vw, 1.9rem);
      }

      .auth-card p {
        margin: 0;
        color: var(--text-muted);
      }

      .auth-field {
        display: grid;
        gap: 0.5rem;
      }

      .auth-field span {
        font-size: 0.95rem;
        color: var(--text-muted);
        letter-spacing: 0.03em;
      }

      .auth-card input[type="password"] {
        width: 100%;
        padding: 0.65rem 0.85rem;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.45);
        background: rgba(15, 23, 42, 0.45);
        color: var(--text);
        font-size: 1rem;
      }

      .auth-card input:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.35);
      }

      .auth-error {
        min-height: 1.2rem;
        color: var(--error);
        font-size: 0.9rem;
      }

      @media (min-width: 720px) {
        .control-grid {
          grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        }

        .control-grid label {
          font-size: 0.9rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Центр управления VPN_GPT</h1>
      <p>
        Выберите действие в понятных терминах, а затем заполните необходимые данные в появляющемся окне.
        Каждый запрос отправляется к API после подтверждения.
      </p>
    </header>
    <main>
      <section class="control-panel">
        <div class="control-grid">
          <label>
            Базовый URL API
            <input type="text" id="base-url" autocomplete="off" value="https://vpn-gpt.store/api" />
          </label>
          <label>
            Токен администратора (X-Admin-Token)
            <input type="text" id="admin-token" autocomplete="off" placeholder="Введите при необходимости" />
          </label>
          <label>
            Поиск по действиям
            <input type="search" id="operation-search" placeholder="Например, пополнить баланс" />
          </label>
        </div>
        <div class="control-actions">
          <button class="button-primary" id="refresh-schema" type="button">Обновить список действий</button>
          <button class="button-secondary" id="clear-search" type="button">Сбросить фильтр</button>
        </div>
        <p class="operations-meta" id="results-summary">Эндпоинты пока не загружены.</p>
      </section>

      <section class="operations-panel" id="operations"></section>

      <div id="status-bar" class="status-bar" role="status" aria-live="polite"></div>
    </main>

    <div class="modal-overlay" id="operation-modal" hidden>
      <div class="modal-card">
        <button class="modal-close" type="button" id="operation-close">Закрыть</button>
        <div class="modal-header">
          <h3 id="operation-title">Выберите действие</h3>
          <p class="modal-path" id="operation-subtitle"></p>
          <p id="operation-description"></p>
        </div>
        <form id="operation-form" class="endpoint-form">
          <div id="operation-fields" class="modal-fields"></div>
          <div class="modal-actions">
            <button class="submit-btn" type="submit">Выполнить</button>
          </div>
          <div class="response">
            <div class="status" id="operation-status">Ответ ещё не запрошен</div>
            <pre id="operation-response"></pre>
          </div>
        </form>
      </div>
    </div>

    <div class="auth-overlay" id="auth-overlay">
      <form class="auth-card" id="auth-form">
        <div>
          <h2>Вход в админ-панель</h2>
          <p>Введите пароль администратора, чтобы получить доступ к действиям.</p>
        </div>
        <div class="auth-field">
          <span>Пароль администратора</span>
          <input type="password" id="admin-password" autocomplete="current-password" required />
        </div>
        <div class="auth-error" id="auth-error"></div>
        <button class="button-primary" id="auth-submit" type="submit">Подтвердить</button>
      </form>
    </div>

    <script>
      const METHOD_PRIORITY = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
      const TAG_ALL_VALUE = "__all";
      const STORAGE_KEYS = {
        baseUrl: "admin-panel.base-url",
        adminToken: "admin-panel.admin-token",
      };
      const DEFAULT_BASE_URL = "https://vpn-gpt.store/api";

      const selectors = {
        baseUrl: document.getElementById("base-url"),
        adminToken: document.getElementById("admin-token"),
        search: document.getElementById("operation-search"),
        refresh: document.getElementById("refresh-schema"),
        clearSearch: document.getElementById("clear-search"),
        operations: document.getElementById("operations"),
        statusBar: document.getElementById("status-bar"),
        resultsSummary: document.getElementById("results-summary"),
        authOverlay: document.getElementById("auth-overlay"),
        authForm: document.getElementById("auth-form"),
        authPassword: document.getElementById("admin-password"),
        authError: document.getElementById("auth-error"),
        authSubmit: document.getElementById("auth-submit"),
        modal: document.getElementById("operation-modal"),
        modalClose: document.getElementById("operation-close"),
        modalTitle: document.getElementById("operation-title"),
        modalSubtitle: document.getElementById("operation-subtitle"),
        modalDescription: document.getElementById("operation-description"),
        modalFields: document.getElementById("operation-fields"),
        operationForm: document.getElementById("operation-form"),
        operationStatus: document.getElementById("operation-status"),
        operationResponse: document.getElementById("operation-response"),
      };

      const state = {
        spec: null,
        operations: [],
        filtered: [],
        filters: {
          query: "",
        },
        session: {
          authenticated: false,
          adminToken: "",
        },
        currentOperation: null,
      };

      function savePreference(key, value) {
        try {
          if (value) {
            window.localStorage.setItem(key, value);
          } else {
            window.localStorage.removeItem(key);
          }
        } catch (error) {
          console.warn("Не удалось сохранить настройки", error);
        }
      }

      function loadPreference(key) {
        try {
          return window.localStorage.getItem(key) || "";
        } catch (error) {
          return "";
        }
      }

      function setStatus(message, tone = "info") {
        selectors.statusBar.textContent = message;
        selectors.statusBar.className = `status-bar visible tone-${tone}`;
      }

      function clearStatus() {
        selectors.statusBar.className = "status-bar";
        selectors.statusBar.textContent = "";
      }

      function resolveBaseUrl() {
        const value = selectors.baseUrl.value.trim();
        if (!value) {
          selectors.baseUrl.value = DEFAULT_BASE_URL;
          return DEFAULT_BASE_URL;
        }
        return value.replace(/\/$/, "");
      }

      function buildApiUrl(pathname) {
        const baseValue = resolveBaseUrl();
        let base;
        try {
          base = new URL(baseValue);
        } catch (error) {
          base = new URL(DEFAULT_BASE_URL);
        }

        if (/^https?:\/\//i.test(pathname)) {
          return new URL(pathname);
        }

        const normalized = pathname.startsWith("/") ? pathname : `/${pathname}`;

        if (normalized.startsWith("/") && base.pathname && base.pathname !== "/") {
          const merged = new URL(base.toString());
          const prefix = merged.pathname.endsWith("/") ? merged.pathname.slice(0, -1) : merged.pathname;
          merged.pathname = `${prefix}${normalized}`;
          return merged;
        }

        try {
          return new URL(normalized, base);
        } catch (error) {
          const fallback = new URL(base.toString());
          const prefix = fallback.pathname.endsWith("/") ? fallback.pathname.slice(0, -1) : fallback.pathname;
          fallback.pathname = `${prefix}${normalized}`;
          return fallback;
        }
      }

      async function authenticateWithPassword(password) {
        const body = new URLSearchParams();
        body.set("password", password);

        const baseValue = resolveBaseUrl();
        let hasApiSegment = false;

        try {
          const parsedBase = new URL(baseValue);
          const path = parsedBase.pathname || "/";
          hasApiSegment = /(^|\/)api(\/|$)/.test(path);
        } catch (error) {
          hasApiSegment = false;
        }

        const candidatePaths = ["/admin/auth"];
        if (!hasApiSegment) {
          candidatePaths.push("/api/admin/auth");
        }

        let lastError = null;

        for (const path of candidatePaths) {
          const url = buildApiUrl(path);

          try {
            return await submitAdminPassword(url, body);
          } catch (error) {
            if (error && (error.status === 404 || error.status === 405)) {
              lastError = error;
              continue;
            }
            throw error;
          }
        }

        throw lastError || new Error("Не удалось авторизоваться");
      }

      async function submitAdminPassword(url, body) {
        const response = await fetch(url.toString(), {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8",
          },
          body,
        });

        let payload = null;
        try {
          payload = await response.json();
        } catch (error) {}

        if (!response.ok) {
          const detail = (payload && (payload.detail || payload.error)) || `Ошибка ${response.status}`;
          const failure = new Error(detail);
          failure.status = response.status;
          failure.payload = payload;
          throw failure;
        }

        if (!payload || payload.ok !== true) {
          const message = (payload && (payload.detail || payload.error)) || "Не удалось авторизоваться";
          throw new Error(message);
        }

        return payload;
      }

      async function loadOpenApi({ silent = false } = {}) {
        if (!state.session.authenticated) {
          if (!silent) {
            setStatus("Введите админ-пароль, чтобы загрузить список действий", "warning");
          }
          return;
        }

        try {
          if (!silent) {
            setStatus("Загружаем OpenAPI-схему…", "info");
          }
          const url = buildApiUrl("/openapi.json");
          const response = await fetch(url.toString(), { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Не удалось загрузить схему: ${response.status}`);
          }
          const spec = await response.json();
          state.spec = spec;
          state.operations = collectOperationsFromSpec(spec);
          state.filtered = state.operations.slice();
          renderOperations();
          const total = state.operations.length;
          const summary = total
            ? `Загружено ${total} действий. Используйте поиск или выберите нужную кнопку.`
            : "Действия не найдены в схеме.";
          setStatus(summary, total ? "success" : "warning");
          setTimeout(clearStatus, 4500);
        } catch (error) {
          console.error(error);
          setStatus(error.message || "Не удалось загрузить OpenAPI", "error");
        }
      }

      function collectOperationsFromSpec(spec) {
        if (!spec || !spec.paths) {
          return [];
        }
        const operations = [];
        Object.entries(spec.paths).forEach(([path, methods]) => {
          Object.entries(methods || {}).forEach(([methodName, operation]) => {
            if (!operation || typeof operation !== "object") {
              return;
            }
            const method = methodName.toUpperCase();
            if (!METHOD_PRIORITY.includes(method)) {
              return;
            }
            const summary = (operation.summary || "").trim();
            const description = (operation.description || "").trim();
            const label = summary || humanizePath(path, method);
            const primaryTag = (operation.tags && operation.tags[0]) || "Общие действия";
            operations.push({
              method,
              path,
              operation,
              summary,
              description,
              label,
              primaryTag,
            });
          });
        });

        operations.sort((a, b) => {
          if (a.primaryTag !== b.primaryTag) {
            return a.primaryTag.localeCompare(b.primaryTag, "ru");
          }
          const methodDiff = METHOD_PRIORITY.indexOf(a.method) - METHOD_PRIORITY.indexOf(b.method);
          if (methodDiff !== 0) {
            return methodDiff;
          }
          return a.path.localeCompare(b.path, "ru");
        });

        operations.forEach((operation, index) => {
          operation.index = index;
        });

        return operations;
      }

      function humanizePath(path, method) {
        const clean = path
          .replace(/^\//, "")
          .replace(/\{([^}]+)\}/g, "«$1»")
          .replace(/[-_]/g, " ")
          .trim();
        const base = clean ? clean : "действие";
        switch (method) {
          case "GET":
            return `Получить: ${base}`;
          case "POST":
            return `Создать или запустить: ${base}`;
          case "PUT":
          case "PATCH":
            return `Обновить: ${base}`;
          case "DELETE":
            return `Удалить: ${base}`;
          default:
            return `${method} ${path}`;
        }
      }
      function renderOperations() {
        const container = selectors.operations;
        container.innerHTML = "";

        const query = (state.filters.query || "").trim().toLowerCase();
        const filtered = !query
          ? state.operations
          : state.operations.filter((operation) => {
              const haystack = [
                operation.label,
                operation.summary,
                operation.description,
                operation.path,
                operation.method,
                ...(operation.operation.tags || []),
              ]
                .join(" ")
                .toLowerCase();
              return haystack.includes(query);
            });

        state.filtered = filtered;
        updateResultsSummary(state.operations.length, filtered.length);

        if (!filtered.length) {
          const empty = document.createElement("div");
          empty.className = "empty-state";
          empty.textContent = state.operations.length
            ? "Ничего не найдено. Измените текст поиска."
            : "Список действий ещё не загружен. Авторизуйтесь и обновите схему.";
          container.appendChild(empty);
          return;
        }

        const groups = new Map();
        filtered.forEach((operation) => {
          const key = operation.primaryTag || TAG_ALL_VALUE;
          if (!groups.has(key)) {
            groups.set(key, []);
          }
          groups.get(key).push(operation);
        });

        groups.forEach((operations, tag) => {
          const section = document.createElement("section");
          section.className = "operation-group";

          const heading = document.createElement("h2");
          heading.textContent = tag;
          section.appendChild(heading);

          const grid = document.createElement("div");
          grid.className = "operation-buttons";

          operations.forEach((operation) => {
            const button = document.createElement("button");
            button.type = "button";
            button.className = "operation-button";
            button.dataset.index = operation.index;

            const label = document.createElement("span");
            label.className = "label";
            label.textContent = operation.label;
            button.appendChild(label);

            const hint = document.createElement("span");
            hint.className = "hint";
            hint.textContent = `${operation.method} ${operation.path}`;
            button.appendChild(hint);

            if (operation.description) {
              const desc = document.createElement("span");
              desc.className = "description";
              desc.textContent = operation.description;
              button.appendChild(desc);
            }

            const badge = document.createElement("span");
            badge.className = `method-badge method-${operation.method.toLowerCase()}`;
            badge.textContent = operation.method;
            button.appendChild(badge);

            button.addEventListener("click", () => openOperationModal(operation));

            grid.appendChild(button);
          });

          section.appendChild(grid);
          container.appendChild(section);
        });
      }

      function openOperationModal(operation) {
        state.currentOperation = operation;
        selectors.modalTitle.textContent = operation.label;
        selectors.modalSubtitle.textContent = `${operation.method} ${operation.path}`;
        selectors.modalDescription.textContent = operation.description || "";
        selectors.operationStatus.textContent = "Ответ ещё не запрошен";
        selectors.operationStatus.className = "status";
        selectors.operationResponse.textContent = "";

        selectors.operationForm.dataset.method = operation.method;
        selectors.operationForm.dataset.path = operation.path;

        selectors.modalFields.innerHTML = "";
        const parameterGroups = buildParameterGroups(operation.operation.parameters || []);
        parameterGroups.forEach((group) => selectors.modalFields.appendChild(group));

        if (operation.operation.requestBody) {
          selectors.modalFields.appendChild(buildRequestBody(operation.operation.requestBody));
        }

        selectors.modalFields.appendChild(buildHeadersFieldset());

        selectors.modal.removeAttribute("hidden");
        const firstInput = selectors.modalFields.querySelector("input, textarea");
        if (firstInput) {
          firstInput.focus();
        } else {
          selectors.operationForm.querySelector(".submit-btn").focus();
        }
      }

      function closeOperationModal() {
        state.currentOperation = null;
        selectors.operationForm.dataset.method = "";
        selectors.operationForm.dataset.path = "";
        selectors.modalFields.innerHTML = "";
        selectors.modal.setAttribute("hidden", "");
      }

      function buildParameterGroups(parameters) {
        const byLocation = new Map();
        parameters.forEach((param) => {
          if (!param || !param.name) return;
          const location = param.in || "query";
          if (!byLocation.has(location)) {
            const fieldset = document.createElement("fieldset");
            fieldset.dataset.group = location;
            const legend = document.createElement("legend");
            legend.textContent =
              location === "path"
                ? "Параметры пути"
                : location === "query"
                ? "Query-параметры"
                : location === "header"
                ? "Заголовки"
                : location === "cookie"
                ? "Cookie"
                : location;
            fieldset.appendChild(legend);
            byLocation.set(location, fieldset);
          }
          const fieldset = byLocation.get(location);
          fieldset.appendChild(buildParameterField(param));
        });
        return Array.from(byLocation.values());
      }

      function buildParameterField(parameter) {
        const wrapper = document.createElement("div");
        wrapper.className = "param-field";

        const label = document.createElement("label");
        label.textContent = parameter.name + (parameter.required ? " *" : "");

        const input = document.createElement("input");
        input.type = "text";
        input.name = parameter.name;
        input.dataset.paramType = parameter.in;
        input.placeholder = parameter.schema?.type || "";
        if (parameter.schema && "default" in parameter.schema) {
          input.value = parameter.schema.default;
        }
        if (parameter.required) {
          input.required = true;
        }

        label.appendChild(input);
        wrapper.appendChild(label);

        if (parameter.description) {
          const meta = document.createElement("div");
          meta.className = "param-meta";
          meta.textContent = parameter.description;
          wrapper.appendChild(meta);
        }
        return wrapper;
      }

      function buildRequestBody(requestBody) {
        const fieldset = document.createElement("fieldset");
        fieldset.dataset.group = "body";
        const legend = document.createElement("legend");
        legend.textContent = "Тело запроса";
        fieldset.appendChild(legend);

        const description = requestBody.description;
        if (description) {
          const meta = document.createElement("div");
          meta.className = "param-meta";
          meta.textContent = description;
          fieldset.appendChild(meta);
        }

        const textarea = document.createElement("textarea");
        textarea.dataset.role = "body";
        textarea.placeholder = "JSON";
        const example = extractExampleFromRequest(requestBody);
        if (example) {
          textarea.value = example;
        }
        fieldset.appendChild(textarea);
        return fieldset;
      }

      function buildHeadersFieldset() {
        const fieldset = document.createElement("fieldset");
        const legend = document.createElement("legend");
        legend.textContent = "Дополнительные заголовки (JSON)";
        fieldset.appendChild(legend);

        const textarea = document.createElement("textarea");
        textarea.dataset.role = "headers";
        textarea.placeholder = '{"Custom-Header": "value"}';
        textarea.rows = 4;
        fieldset.appendChild(textarea);
        return fieldset;
      }

      function extractExampleFromRequest(requestBody) {
        const content = requestBody.content || {};
        const jsonContent = content["application/json"] || content["application/*"];
        if (!jsonContent) {
          return "";
        }
        const example =
          jsonContent.example ||
          (Array.isArray(jsonContent.examples)
            ? jsonContent.examples[0]
            : jsonContent.examples && typeof jsonContent.examples === "object"
            ? Object.values(jsonContent.examples)[0]?.value
            : null);
        if (example) {
          return formatJson(example);
        }
        const schema = jsonContent.schema;
        if (!schema) return "";
        const sample = buildSampleFromSchema(schema, state.spec?.components?.schemas || {});
        return sample ? formatJson(sample) : "";
      }

      function buildSampleFromSchema(schema, definitions, stack = new Set()) {
        if (!schema) return null;
        if (schema.example !== undefined) {
          return schema.example;
        }
        if (schema.$ref) {
          const ref = schema.$ref.replace("#/components/schemas/", "");
          if (stack.has(ref)) {
            return null;
          }
          stack.add(ref);
          const resolved = definitions?.[ref];
          const value = buildSampleFromSchema(resolved, definitions, stack);
          stack.delete(ref);
          return value;
        }
        const type = schema.type;
        if (type === "object" || (!type && schema.properties)) {
          const result = {};
          const props = schema.properties || {};
          Object.entries(props).forEach(([key, value]) => {
            result[key] = buildSampleFromSchema(value, definitions, stack) ?? null;
          });
          return result;
        }
        if (type === "array") {
          const item = buildSampleFromSchema(schema.items, definitions, stack);
          return item === null ? [] : [item];
        }
        if (type === "integer" || type === "number") {
          return schema.default ?? 0;
        }
        if (type === "boolean") {
          return schema.default ?? false;
        }
        return schema.default ?? "";
      }

      function formatJson(value) {
        if (typeof value === "string") {
          try {
            return JSON.stringify(JSON.parse(value), null, 2);
          } catch (error) {
            return value;
          }
        }
        try {
          return JSON.stringify(value, null, 2);
        } catch (error) {
          return "";
        }
      }
      async function submitRequest(form, statusEl, preEl) {
        const method = form.dataset.method;
        const path = form.dataset.path;
        let urlPath = path;
        const pathInputs = form.querySelectorAll('[data-param-type="path"]');
        for (const input of pathInputs) {
          const value = input.value.trim();
          if (!value && input.required) {
            statusEl.className = "status error";
            statusEl.textContent = `Параметр ${input.name} обязателен.`;
            return;
          }
          urlPath = urlPath.replace(`{${input.name}}`, encodeURIComponent(value));
        }
        const url = buildApiUrl(urlPath);
        const queryInputs = form.querySelectorAll('[data-param-type="query"]');
        const query = new URLSearchParams(url.search);
        for (const input of queryInputs) {
          const value = input.value.trim();
          if (!value) continue;
          query.set(input.name, value);
        }
        const search = query.toString();
        url.search = search;

        const headers = {
          Accept: "application/json, text/plain;q=0.9, */*;q=0.8",
        };
        const token = selectors.adminToken.value.trim();
        if (token) {
          headers["X-Admin-Token"] = token;
        }

        const extraHeadersField = form.querySelector('textarea[data-role="headers"]');
        const extraHeadersText = extraHeadersField ? extraHeadersField.value.trim() : "";
        if (extraHeadersText) {
          try {
            const parsed = JSON.parse(extraHeadersText);
            Object.entries(parsed).forEach(([key, value]) => {
              if (value !== undefined && value !== null) {
                headers[key] = String(value);
              }
            });
          } catch (error) {
            statusEl.className = "status error";
            statusEl.textContent = `Ошибка парсинга заголовков: ${error.message}`;
            return;
          }
        }

        const requestInit = {
          method,
          headers,
        };

        const bodyField = form.querySelector('textarea[data-role="body"]');
        if (bodyField && method !== "GET" && method !== "DELETE") {
          const bodyValue = bodyField.value.trim();
          if (bodyValue) {
            try {
              JSON.parse(bodyValue);
              requestInit.body = bodyValue;
              headers["Content-Type"] = "application/json";
            } catch (error) {
              statusEl.className = "status error";
              statusEl.textContent = `Некорректный JSON: ${error.message}`;
              return;
            }
          }
        }

        statusEl.className = "status pending";
        statusEl.textContent = "Выполняем запрос…";
        preEl.textContent = "";

        try {
          const response = await fetch(url.toString(), requestInit);
          const text = await response.text();
          let formatted = text;
          try {
            formatted = JSON.stringify(JSON.parse(text), null, 2);
          } catch (error) {}
          const statusLine = `${response.status} ${response.statusText || ""}`.trim();
          statusEl.className = response.ok ? "status ok" : "status error";
          statusEl.textContent = `Ответ: ${statusLine}`;
          preEl.textContent = formatted || "(пустой ответ)";
        } catch (error) {
          statusEl.className = "status error";
          statusEl.textContent = `Ошибка запроса: ${error.message}`;
          preEl.textContent = "";
        }
      }

      function updateResultsSummary(total, shown) {
        if (!selectors.resultsSummary) return;
        if (!total) {
          selectors.resultsSummary.textContent = "Эндпоинты пока не загружены.";
          return;
        }
        const prefix = shown === total ? "Показаны все" : `Показано ${shown} из ${total}`;
        selectors.resultsSummary.textContent = `${prefix} действий`;
      }

      function markAuthenticated(adminToken, { silent = false } = {}) {
        state.session.authenticated = true;
        state.session.adminToken = adminToken || "";
        selectors.authOverlay.hidden = true;
        selectors.authError.textContent = "";
        selectors.authPassword.value = "";

        if (adminToken && !selectors.adminToken.value) {
          selectors.adminToken.value = adminToken;
        }

        savePreference(STORAGE_KEYS.adminToken, selectors.adminToken.value.trim());

        if (!silent) {
          const tone = adminToken ? "success" : "warning";
          const message = adminToken
            ? "Авторизация успешна. Загружаем схему…"
            : "Авторизация успешна, но ADMIN_TOKEN не задан. Укажите его вручную.";
          setStatus(message, tone);
        }
      }

      selectors.operationForm.addEventListener("submit", (event) => {
        event.preventDefault();
        submitRequest(selectors.operationForm, selectors.operationStatus, selectors.operationResponse);
      });

      selectors.modalClose.addEventListener("click", () => {
        closeOperationModal();
      });

      selectors.modal.addEventListener("click", (event) => {
        if (event.target === selectors.modal) {
          closeOperationModal();
        }
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && !selectors.modal.hasAttribute("hidden")) {
          closeOperationModal();
        }
      });

      selectors.refresh.addEventListener("click", () => {
        loadOpenApi();
      });

      selectors.clearSearch.addEventListener("click", () => {
        selectors.search.value = "";
        state.filters.query = "";
        renderOperations();
      });

      selectors.search.addEventListener("input", () => {
        state.filters.query = selectors.search.value;
        renderOperations();
      });

      selectors.baseUrl.addEventListener("change", () => {
        savePreference(STORAGE_KEYS.baseUrl, selectors.baseUrl.value.trim());
      });

      selectors.baseUrl.addEventListener("blur", () => {
        savePreference(STORAGE_KEYS.baseUrl, selectors.baseUrl.value.trim());
      });

      selectors.adminToken.addEventListener("input", () => {
        savePreference(STORAGE_KEYS.adminToken, selectors.adminToken.value.trim());
      });

      if (selectors.authForm) {
        selectors.authForm.addEventListener("submit", async (event) => {
          event.preventDefault();
          selectors.authError.textContent = "";
          const password = selectors.authPassword.value.trim();
          if (!password) {
            selectors.authError.textContent = "Введите пароль";
            selectors.authPassword.focus();
            return;
          }

          const button = selectors.authSubmit;
          const originalText = button.textContent;
          button.disabled = true;
          button.textContent = "Проверяем…";

          try {
            const payload = await authenticateWithPassword(password);
            markAuthenticated(payload.admin_token || "", { silent: true });
            await loadOpenApi({ silent: true });
            const hasToken = Boolean(payload.admin_token);
            const message = hasToken
              ? "Авторизация успешна. Схема успешно обновлена"
              : "Схема обновлена. ADMIN_TOKEN не настроен, введите его вручную";
            setStatus(message, hasToken ? "success" : "warning");
            setTimeout(clearStatus, 3500);
          } catch (error) {
            selectors.authError.textContent = error.message || "Не удалось авторизоваться";
            selectors.authPassword.select();
            selectors.authPassword.focus();
          } finally {
            button.disabled = false;
            button.textContent = originalText;
          }
        });
      }

      window.addEventListener("DOMContentLoaded", () => {
        const storedBaseUrl = loadPreference(STORAGE_KEYS.baseUrl);
        if (storedBaseUrl) {
          selectors.baseUrl.value = storedBaseUrl;
        } else {
          selectors.baseUrl.value = DEFAULT_BASE_URL;
        }
        const storedToken = loadPreference(STORAGE_KEYS.adminToken);
        if (storedToken) {
          selectors.adminToken.value = storedToken;
        }
        resolveBaseUrl();
        selectors.authOverlay.hidden = false;
        selectors.authPassword.focus();
        updateResultsSummary(0, 0);
      });
    </script>
  </body>
</html>
